import { Hono } from "hono";
import { HTTPException } from "hono/http-exception";
import type { Innertube } from "youtubei.js";

const channels = new Hono();

interface Thumbnail {
    url: string;
    width: number;
    height: number;
}

interface VideoThumbnail {
    quality: string;
    url: string;
    width: number;
    height: number;
}

interface LatestVideo {
    type: string;
    title: string;
    videoId: string;
    author: string;
    authorId: string;
    authorUrl: string;
    authorVerified: boolean;
    videoThumbnails: VideoThumbnail[];
    description: string;
    descriptionHtml: string;
    viewCount: number;
    viewCountText: string;
    published: number;
    publishedText: string;
    lengthSeconds: number;
    liveNow: boolean;
    premium: boolean;
    isUpcoming: boolean;
    isNew: boolean;
    is4k: boolean;
    is8k: boolean;
    isVr180: boolean;
    isVr360: boolean;
    is3d: boolean;
    hasCaptions: boolean;
}

interface ChannelResponse {
    author: string;
    authorId: string;
    authorUrl: string;
    authorBanners: Thumbnail[];
    authorThumbnails: Thumbnail[];
    subCount: number;
    totalViews: number;
    joined: number;
    autoGenerated: boolean;
    ageGated: boolean;
    isFamilyFriendly: boolean;
    description: string;
    descriptionHtml: string;
    allowedRegions: string[];
    tabs: string[];
    tags: string[];
    authorVerified: boolean;
    latestVideos: LatestVideo[];
    relatedChannels: any[];
}

// Helper to parse subscriber count text to number
function parseSubCount(text: string | undefined): number {
    if (!text) return 0;
    const cleanText = text.replace(/subscribers?/i, "").trim();
    const multipliers: { [key: string]: number } = {
        'K': 1000,
        'M': 1000000,
        'B': 1000000000
    };
    const match = cleanText.match(/([\d.]+)\s*([KMB])?/i);
    if (match) {
        const num = parseFloat(match[1]);
        const suffix = match[2]?.toUpperCase();
        return suffix ? Math.round(num * multipliers[suffix]) : Math.round(num);
    }
    return parseInt(cleanText.replace(/[,\s]/g, "")) || 0;
}

// Helper to parse view count text
function parseViewCount(text: string | undefined): number {
    if (!text) return 0;
    const match = text.match(/([\d,]+)/);
    if (match) {
        return parseInt(match[1].replace(/,/g, "")) || 0;
    }
    return 0;
}

// Helper to generate video thumbnails
function generateVideoThumbnails(videoId: string): VideoThumbnail[] {
    const baseUrl = "https://i.ytimg.com";
    return [
        { quality: "maxres", url: `${baseUrl}/vi/${videoId}/maxresdefault.jpg`, width: 1280, height: 720 },
        { quality: "sddefault", url: `${baseUrl}/vi/${videoId}/sddefault.jpg`, width: 640, height: 480 },
        { quality: "high", url: `${baseUrl}/vi/${videoId}/hqdefault.jpg`, width: 480, height: 360 },
        { quality: "medium", url: `${baseUrl}/vi/${videoId}/mqdefault.jpg`, width: 320, height: 180 },
        { quality: "default", url: `${baseUrl}/vi/${videoId}/default.jpg`, width: 120, height: 90 },
    ];
}

// GET /:channelId - Get channel information
channels.get("/:channelId", async (c) => {
    const channelId = c.req.param("channelId");
    const innertubeClient = c.get("innertubeClient") as Innertube;

    if (!channelId) {
        throw new HTTPException(400, { message: "Channel ID is required" });
    }

    console.log(`[INFO] Fetching channel: ${channelId}`);

    try {
        const channel = await innertubeClient.getChannel(channelId);

        // Extract channel metadata
        const metadata = channel.metadata as any;
        const header = channel.header as any;
        const headerContent = header?.content;

        // Parse banners from header.content.banner.image
        const authorBanners: Thumbnail[] = [];
        if (headerContent?.banner?.image && Array.isArray(headerContent.banner.image)) {
            for (const img of headerContent.banner.image) {
                authorBanners.push({
                    url: img.url,
                    width: img.width || 0,
                    height: img.height || 0
                });
            }
        }

        // Parse thumbnails from header.content.image.avatar.image
        const authorThumbnails: Thumbnail[] = [];
        if (headerContent?.image?.avatar?.image && Array.isArray(headerContent.image.avatar.image)) {
            for (const img of headerContent.image.avatar.image) {
                authorThumbnails.push({
                    url: img.url,
                    width: img.width || 0,
                    height: img.height || 0
                });
            }
        }
        // Fallback: try metadata.thumbnail
        if (authorThumbnails.length === 0 && metadata?.thumbnail && Array.isArray(metadata.thumbnail)) {
            for (const img of metadata.thumbnail) {
                authorThumbnails.push({
                    url: img.url,
                    width: img.width || 0,
                    height: img.height || 0
                });
            }
        }

        // Parse subscriber count from header.content.metadata.metadata_rows
        let subscriberText = "";
        if (headerContent?.metadata?.metadata_rows) {
            for (const row of headerContent.metadata.metadata_rows) {
                if (row.metadata_parts) {
                    for (const part of row.metadata_parts) {
                        const text = part.text?.text || "";
                        if (text.includes("subscriber")) {
                            subscriberText = text;
                            break;
                        }
                    }
                }
                if (subscriberText) break;
            }
        }

        // Get latest videos
        const latestVideos: LatestVideo[] = [];
        const videosTab = channel.has_videos ? await channel.getVideos() : null;
        if (videosTab?.videos) {
            for (const video of videosTab.videos.slice(0, 20)) { // Limit to 20 videos
                const v = video as any;
                latestVideos.push({
                    type: "video",
                    title: v.title?.text || "",
                    videoId: v.id || "",
                    author: metadata?.title || "",
                    authorId: channelId,
                    authorUrl: `/channel/${channelId}`,
                    authorVerified: metadata?.is_verified || false,
                    videoThumbnails: generateVideoThumbnails(v.id || ""),
                    description: v.description_snippet?.text || "",
                    descriptionHtml: v.description_snippet?.text || "",
                    viewCount: parseViewCount(v.view_count?.text),
                    viewCountText: v.view_count?.text || "",
                    published: 0, // Timestamp not easily available
                    publishedText: v.published?.text || "",
                    lengthSeconds: v.duration?.seconds || 0,
                    liveNow: v.is_live || false,
                    premium: false,
                    isUpcoming: v.is_upcoming || false,
                    isNew: false,
                    is4k: false,
                    is8k: false,
                    isVr180: false,
                    isVr360: false,
                    is3d: false,
                    hasCaptions: false
                });
            }
        }

        // Get tabs
        const tabs: string[] = [];
        const channelAny = channel as any;
        if (channelAny.has_home) tabs.push("home");
        if (channelAny.has_videos) tabs.push("videos");
        if (channelAny.has_shorts) tabs.push("shorts");
        if (channelAny.has_live) tabs.push("live");
        if (channelAny.has_playlists) tabs.push("playlists");
        if (channelAny.has_community) tabs.push("community");

        const response: ChannelResponse = {
            author: metadata?.title || "",
            authorId: channelId,
            authorUrl: `/channel/${channelId}`,
            authorBanners: authorBanners,
            authorThumbnails: authorThumbnails,
            subCount: parseSubCount(subscriberText),
            totalViews: 0, // Not easily available
            joined: 0, // Not easily available
            autoGenerated: false,
            ageGated: false,
            isFamilyFriendly: true,
            description: metadata?.description || "",
            descriptionHtml: metadata?.description || "",
            allowedRegions: [],
            tabs: tabs,
            tags: metadata?.keywords || [],
            authorVerified: metadata?.is_verified || false,
            latestVideos: latestVideos,
            relatedChannels: []
        };

        return c.json(response);
    } catch (error) {
        console.error(`[ERROR] Failed to fetch channel ${channelId}:`, error);
        throw new HTTPException(500, { message: `Failed to fetch channel: ${error}` });
    }
});

export default channels;
